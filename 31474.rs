pub use __cargo_equip::prelude::*;

#[allow(unused_imports)]
#[allow(dead_code)]
use std::collections::*;
use std::str::FromStr;
use std::cmp::{min, max};

use bigint::BigInt;

fn main() {
	let mut oj = io_short::stdin();
    let n = oj.i64();
    let mut a = 1;
    let mut v = 1;
    while v<n {
        a*=v;
        v+=2;
    }
    oj.write(a);
}

// The following code was expanded by `cargo-equip`.

///  # Bundled libraries
/// 
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets#ps-snippets@0.1.0`                              published in **missing** licensed under **missing** as `crate::__cargo_equip::crates::ps_snippets`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/ds/bitset#0.1.0`                         published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::bitset`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/ds/disjoint_set#0.1.0`                   published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::disjoint_set`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/ds/fenwick#0.1.0`                        published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::fenwick`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/ds/lazy_segtree#0.1.0`                   published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::lazy_segtree`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/ds/lazy_segtree_dyn#0.1.0`               published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::lazy_segtree_dyn`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/geom_simple/polygon_simple#0.1.0`        published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::polygon_simple`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/graph/bfs#0.1.0`                         published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::bfs`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/graph/bicolor#0.1.0`                     published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::bicolor`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/graph/bottleneck_hungarian#0.1.0`        published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::bottleneck_hungarian`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/graph/dijkstra#0.1.0`                    published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::dijkstra`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/graph/edge_list#0.1.0`                   published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::edge_list`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/graph/hungarian#0.1.0`                   published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::hungarian`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/graph/scc#0.1.0`                         published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::scc`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/graph/toposort#0.1.0`                    published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::toposort`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/graph/tree/compress#tree_compress@0.1.0` published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::tree_compress`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/graph/tree/hld#0.1.0`                    published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::hld`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/io/io#0.1.0`                             published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::io`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/io/io_short#0.1.0`                       published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::io_short`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/math/enum_comb#0.1.0`                    published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::enum_comb`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/math/gcd#0.1.0`                          published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::gcd`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/math/kth_root#0.1.0`                     published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::kth_root`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/math/modpow#0.1.0`                       published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::modpow`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/math/psuedo_rand#0.1.0`                  published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::psuedo_rand`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/math/sieve#0.1.0`                        published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::sieve`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/misc/bigint#0.1.0`                       published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::bigint`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/misc/binary_search#0.1.0`                published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::binary_search`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/misc/bit_helper#0.1.0`                   published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::bit_helper`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/misc/calendar#0.1.0`                     published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::calendar`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/misc/dnc_opt#0.1.0`                      published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::dnc_opt`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/misc/gadgets#0.1.0`                      published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::gadgets`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/misc/lis#0.1.0`                          published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::lis`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/misc/two_sat#0.1.0`                      published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::two_sat`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/number/fraction#0.1.0`                   published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::fraction`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/number/harmonic_lemma#0.1.0`             published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::harmonic_lemma`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/number/modfact#0.1.0`                    published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::modfact`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/number/modint#0.1.0`                     published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::modint`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/number/ord_f64#0.1.0`                    published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::ord_f64`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/prime/factorization#0.1.0`               published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::factorization`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/prime/primality#0.1.0`                   published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::primality`
///  - `path+file:///C:/Users/natha/Desktop/backup/ps_snippets/crates/string/ascii#0.1.0`                      published in **missing** licensed under `CC0-1.0`   as `crate::__cargo_equip::crates::ascii`
#[cfg_attr(any(), rustfmt::skip)]
#[allow(unused)]
mod __cargo_equip {
    pub(crate) mod crates {
        pub mod ps_snippets {}
        pub mod bitset {#[derive(Clone)]pub struct Bitset(pub Vec<u64>,pub usize);impl Bitset{pub fn new(n:usize)->Self{let v=vec![0;(n+63)/64];Self(v,n)}pub fn len(&self)->usize{self.1}pub fn set(&mut self,i:usize,v:bool){if v{self.0[i/64]|=1<<(i%64);}else{self.0[i/64]&=!(1<<(i%64));}}pub fn get(&self,i:usize)->bool{(self.0[i/64]>>(i%64))&1==1}#[target_feature(enable="avx2")]pub unsafe fn shr(&self,x:usize)->Self{let mut shr=Self::new(self.len()-x);let x_chunk=x/64;let x_inside=(x%64)as u32;if x_inside==0{for(dest,&src)in shr.0.iter_mut().zip(self.0[x_chunk..].iter()){*dest=src;}}else{for(dest,&src)in shr.0.iter_mut().zip(self.0[x_chunk..].iter()){*dest=src>>x_inside;}for(dest,&src)in shr.0.iter_mut().zip(self.0[x_chunk+1..].iter()){*dest|=(src&((1<<x_inside)-1))<<(64-x_inside);}}shr}pub fn flip(&mut self,i:usize){self.0[i/64]^=1<<(i%64);}pub fn shl(&self,x:usize)->Self{let mut shl=unsafe{Self::new(self.len()+x)};let x_chunk=x/64;let x_inside=(x%64)as u32;if x_inside==0{for(dest,src)in shl.0.iter_mut().skip(x_chunk).zip(self.0.clone()){*dest=src.wrapping_shl(x_inside);}}else{let mut low=0;for(dest,src)in shl.0.iter_mut().skip(x_chunk).zip(self.0.clone()){*dest=src.wrapping_shl(x_inside)|low;low=src>>(64-x_inside);}if shl.0.len()>self.0.len()+x_chunk{*shl.0.last_mut().unwrap()=low;}}shl}#[target_feature(enable="avx2")]pub unsafe fn or(&mut self,other:&Self){for(a,&b)in self.0.iter_mut().zip(&other.0){*a|=b;}}}impl std::fmt::Debug for Bitset{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{let mut iter=self.0.iter().rev().skip_while(|&&b|b==0);if let Some(&first)=iter.next(){write!(f,"{first:b}")?;for&b in iter{write!(f,"{b:064b}")?;}Ok(())}else{write!(f,"0")}}}}
        pub mod disjoint_set {pub struct DisjointSet{par:Vec<usize>,}impl DisjointSet{pub fn new(n:usize)->Self{Self{par:(0..n).collect(),}}pub fn len(&self)->usize{self.par.len()}pub fn join(&mut self,a:usize,b:usize){let ar=self.find(a);self.par[ar]=self.find(b);}pub fn find(&mut self,mut i:usize)->usize{while self.par[i]!=i{self.par[i]=self.par[self.par[i]];i=self.par[i];}i}}}
        pub mod fenwick {pub trait FenwickOp{type V:Clone;fn add(cur:&mut Self::V,val:&Self::V);}pub trait InvOp:FenwickOp{fn sub(cur:&mut<Self as FenwickOp>::V,val:&<Self as FenwickOp>::V);}#[derive(Clone,Debug,Default,PartialEq,Eq)]pub struct Fenwick<T:FenwickOp>(Vec<T::V>);impl<T:FenwickOp>From<Vec<T::V>>for Fenwick<T>{fn from(mut value:Vec<T::V>)->Self{for i in 0..value.len(){let v=&value[i].clone();if let Some(cur)=value.get_mut(i|(i+1)){T::add(cur,v);}}Self(value)}}impl<T:FenwickOp>Fenwick<T>{pub fn new_from_identity(n:usize,identity:T::V)->Self{Self(vec![identity;n])}pub fn len(&self)->usize{self.0.len()}pub fn add(&mut self,mut i:usize,v:&T::V){assert!(i<self.len());while let Some(cur)=self.0.get_mut(i){T::add(cur,v);i|=i+1;}}pub fn prefix_sum(&self,mut i:usize)->T::V{assert!(i<self.len());let mut ans=self.0[i].clone();loop{i&=i+1;i=if i!=0{i-1}else{return ans};T::add(&mut ans,&self.0[i]);}}}impl<T:FenwickOp+InvOp>Fenwick<T>{pub fn sum(&self,l:usize,r:usize)->T::V{assert!(l<=r,"Bad query range [{}, {}]",l,r);let mut vr=self.prefix_sum(r);if l!=0{T::sub(&mut vr,&self.prefix_sum(l-1));}vr}}macro_rules!impl_fenwick_sum{($($T:ty)*)=>{$(impl FenwickOp for$T{type V=$T;fn add(cur:&mut$T,val:&$T){*cur+=*val;}}impl InvOp for$T{fn sub(cur:&mut$T,val:&$T){*cur-=*val;}})*};}impl_fenwick_sum!(u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);}
        pub mod lazy_segtree {use std::fmt::Debug;pub trait LazyMonoid{type V:Clone+Debug;type L:Clone+Debug+PartialEq;const ID:Self::V;fn op(x:&Self::V,y:&Self::V)->Self::V;const NOT_LAZY:Self::L;fn combine_lazy(cur:&mut Self::L,up:&Self::L);fn unlazy(slot:&mut Self::V,lazy:Self::L,nl:usize,nr:usize);}#[derive(Clone)]pub struct LazySegtree<T:LazyMonoid>{n:usize,arr:Vec<T::V>,lazy:Vec<T::L>,}impl<T:LazyMonoid>Debug for LazySegtree<T>{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{f.debug_struct("LazySegtree").field("n",&self.n).field("arr",&self.arr).field("lazy",&self.lazy).finish()}}impl<T:LazyMonoid>LazySegtree<T>{pub fn new(size:usize,init:impl Fn(usize)->T::V)->Self{let mut n=1usize;while n<size{n<<=1;}let mut arr=vec![T::ID;n*2];let lazy=vec![T::NOT_LAZY;n*2];for(i,slot)in arr[n..n+size].iter_mut().enumerate(){*slot=init(i);}for i in(1..n).rev(){arr[i]=T::op(&arr[i*2],&arr[i*2+1]);}Self{n,arr,lazy}}fn propagate(&mut self,i:usize,nl:usize,nr:usize){if self.lazy[i]==T::NOT_LAZY{return;}let lazy=std::mem::replace(&mut self.lazy[i],T::NOT_LAZY);if i<self.n{T::combine_lazy(&mut self.lazy[i*2],&lazy);T::combine_lazy(&mut self.lazy[i*2+1],&lazy);}T::unlazy(&mut self.arr[i],lazy,nl,nr);}pub fn update(&mut self,l:usize,r:usize,lazy:T::L){self.update_inner(l,r,&lazy,1,0,self.n-1);}fn update_inner(&mut self,l:usize,r:usize,lazy:&T::L,i:usize,nl:usize,nr:usize){self.propagate(i,nl,nr);if r<nl||nr<l{return;}if l<=nl&&nr<=r{T::combine_lazy(&mut self.lazy[i],lazy);self.propagate(i,nl,nr);return;}let m=(nl+nr)/2;self.update_inner(l,r,lazy,i*2,nl,m);self.update_inner(l,r,lazy,i*2+1,m+1,nr);self.arr[i]=T::op(&self.arr[i*2],&self.arr[i*2+1]);}pub fn query(&mut self,l:usize,r:usize)->T::V{self.query_inner(l,r,1,0,self.n-1)}fn query_inner(&mut self,l:usize,r:usize,i:usize,nl:usize,nr:usize)->T::V{self.propagate(i,nl,nr);if r<nl||nr<l{return T::ID;}if l<=nl&&nr<=r{return self.arr[i].clone();}let m=(nl+nr)/2;T::op(&self.query_inner(l,r,i*2,nl,m),&self.query_inner(l,r,i*2+1,m+1,nr),)}}}
        pub mod lazy_segtree_dyn {use std::fmt::Debug;pub struct LazySegtreeDyn<'a,V,L>{n:usize,arr:Vec<V>,lazy:Vec<L>,id:V,op:Box<dyn Fn(&V,&V)->V+'a>,not_lazy:L,combine_lazy:Box<dyn Fn(&mut L,&L)+'a>,unlazy:Box<dyn Fn(&mut V,L,usize,usize)+'a>,}impl<'a,V:Debug,L:Debug>Debug for LazySegtreeDyn<'a,V,L>{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{f.debug_struct("LazySegtree").field("n",&self.n).field("arr",&self.arr).field("lazy",&self.lazy).finish()}}impl<'a,V:Clone,L:PartialEq+Clone>LazySegtreeDyn<'a,V,L>{pub fn new(size:usize,init:impl Fn(usize)->V+'a,id:V,op:impl Fn(&V,&V)->V+'a,not_lazy:L,combine_lazy:impl Fn(&mut L,&L)+'a,unlazy:impl Fn(&mut V,L,usize,usize)+'a,)->Self{let mut n=1usize;while n<size{n<<=1;}let mut arr=vec![id.clone();n*2];let lazy=vec![not_lazy.clone();n*2];for(i,slot)in arr[n..n+size].iter_mut().enumerate(){*slot=init(i);}for i in(1..n).rev(){arr[i]=op(&arr[i*2],&arr[i*2+1]);}Self{n,arr,lazy,id,op:Box::new(op),not_lazy,combine_lazy:Box::new(combine_lazy),unlazy:Box::new(unlazy),}}fn propagate(&mut self,i:usize,nl:usize,nr:usize){if self.lazy[i]==self.not_lazy{return;}let lazy=std::mem::replace(&mut self.lazy[i],self.not_lazy.clone());if i<self.n{(self.combine_lazy)(&mut self.lazy[i*2],&lazy);(self.combine_lazy)(&mut self.lazy[i*2+1],&lazy);}(self.unlazy)(&mut self.arr[i],lazy,nl,nr);}pub fn update(&mut self,l:usize,r:usize,lazy:L){self.update_inner(l,r,&lazy,1,0,self.n-1);}fn update_inner(&mut self,l:usize,r:usize,lazy:&L,i:usize,nl:usize,nr:usize){self.propagate(i,nl,nr);if r<nl||nr<l{return;}if l<=nl&&nr<=r{(self.combine_lazy)(&mut self.lazy[i],lazy);self.propagate(i,nl,nr);return;}let m=(nl+nr)/2;self.update_inner(l,r,lazy,i*2,nl,m);self.update_inner(l,r,lazy,i*2+1,m+1,nr);self.arr[i]=(self.op)(&self.arr[i*2],&self.arr[i*2+1]);}pub fn query(&mut self,l:usize,r:usize)->V{self.query_inner(l,r,1,0,self.n-1)}fn query_inner(&mut self,l:usize,r:usize,i:usize,nl:usize,nr:usize)->V{self.propagate(i,nl,nr);if r<nl||nr<l{return self.id.clone();}if l<=nl&&nr<=r{return self.arr[i].clone();}let m=(nl+nr)/2;let left=self.query_inner(l,r,i*2,nl,m);let right=self.query_inner(l,r,i*2+1,m+1,nr);(self.op)(&left,&right)}}}
        pub mod polygon_simple {use std::ops::*;pub fn twice_signed_area<T>(poly:&[(T,T)])->T where T:Default+Add<Output=T>+Mul<Output=T>+Sub<Output=T>+std::iter::Sum<T>+Copy,{let n=poly.len();if n<=2{return T::default();}poly.windows(2).map(|w|w[0].0*w[1].1-w[0].1*w[1].0).sum::<T>()+poly[n-1].0*poly[0].1-poly[0].0*poly[n-1].1}}
        pub mod bfs {use crate::__cargo_equip::preludes::bfs::*;use crate::__cargo_equip::crates::edge_list as edge_list;use std::collections::VecDeque;use edge_list::Graph;pub fn bfs<T>(graph:&Graph<T>,v:usize)->Vec<Option<u32>>{let mut dist=vec![None;graph.vertex_count()];dist[v]=Some(0);let mut queue=VecDeque::from([v]);while let Some(from)=queue.pop_front(){let d=dist[from].unwrap();for(to,_)in graph.neighbors(from){if let Some(nd)=dist[to]{if nd<=d+1{continue;}}dist[to]=Some(d+1);queue.push_back(to);}}dist}}
        pub mod bicolor {use crate::__cargo_equip::preludes::bicolor::*;use crate::__cargo_equip::crates::edge_list as edge_list;use edge_list::Graph;pub fn bicolor_graph(graph:&Graph<bool>)->Option<Vec<bool>>{let mut color=vec![None;graph.vertex_count()];for start in 0..graph.vertex_count(){if color[start].is_some(){continue;}let mut stack=vec![start];color[start]=Some(false);while let Some(a)=stack.pop(){let col_a=color[a].unwrap();for(b,cost)in graph.neighbors(a){let col_b=col_a!=*cost;if color[b]==Some(!col_b){return None;}if color[b].is_none(){stack.push(b);}color[b]=Some(col_b);}}}Some(color.into_iter().map(|b|b.unwrap()).collect())}}
        pub mod bottleneck_hungarian {#[derive(Debug,Clone,Default)]pub struct BottleneckHungarian{mat:Vec<Vec<i64>>,perm:Vec<usize>,inv_perm:Vec<usize>,}impl BottleneckHungarian{pub fn solve(mat:Vec<Vec<i64>>)->Self{let mut solver=Self::default();for row in mat{solver.add_row(row);}solver}pub fn height(&self)->usize{self.mat.len()}pub fn width(&self)->usize{if self.mat.is_empty(){return 0;}self.mat[0].len()}pub fn cost(&self)->i64{self.mat.iter().zip(self.perm.iter()).map(|(row,j)|row[*j]).max().unwrap()}pub fn permutation(&self)->&[usize]{&self.perm}pub fn add_row(&mut self,row:Vec<i64>){let(n,mut m)=(self.height(),self.width());if n==0{m=row.len();self.inv_perm=vec![usize::MAX;m+1];}else{assert!(n<=m,"too many rows");assert_eq!(m,row.len(),"matrix must be rectangular");}self.mat.push(row);self.perm.push(0);let mut minv=vec![i64::MAX;m];let mut augment=vec![0;m];let mut used=vec![false;m+1];self.inv_perm[m]=n;let mut j_cur=m;loop{let i=self.inv_perm[j_cur];if i==usize::MAX{break;}let row=&self.mat[i];used[j_cur]=true;j_cur=used.iter().zip(row).zip(&mut minv).enumerate().filter(|(_,((used,_),_))|!**used).map(|(j,((_,rj),mvj))|{if*rj<*mvj{*mvj=*rj;augment[j]=j_cur;}(*mvj,j)}).min().unwrap().1;}while j_cur!=m{let j_prev=augment[j_cur];self.inv_perm[j_cur]=self.inv_perm[j_prev];self.perm[self.inv_perm[j_cur]]=j_cur;j_cur=j_prev;}}}}
        pub mod dijkstra {use std::{cmp::Reverse,collections::BinaryHeap,ops::Add};#[derive(Clone,Debug,Default)]pub struct Dijkstra<T>{pub adj:Vec<Vec<(usize,T)>>,pub dist:Vec<Option<T>>,prv:Vec<Option<usize>>,}impl<T>Dijkstra<T>where T:Clone+Default+Ord+Add<Output=T>,{#[inline]#[must_use]pub fn new(n:usize)->Self{Self{adj:vec![vec![];n],dist:vec![],prv:vec![],}}#[inline]#[must_use]pub fn n(&self)->usize{self.adj.len()}#[inline]fn verify_vertex(&self,v:usize){assert!(v<self.n(),"invalid vertex {}",v);}#[inline]pub fn connect(&mut self,a:usize,b:usize,cost:T){self.verify_vertex(a);self.verify_vertex(b);assert!(cost>=T::default(),"negative cost");self.adj[a].push((b,cost));}#[inline]pub fn disconnect(&mut self,a:usize,b:usize)->Option<T>{let i=self.adj[a].iter().position(|&(v,_)|v==b)?;let(_,cost)=self.adj[a].remove(i);Some(cost)}pub fn solve(&mut self,start:usize)->&Vec<Option<T>>{self.verify_vertex(start);let mut dist=vec![None;self.n()];dist[start]=Some(T::default());self.prv=vec![None;self.n()];let mut pq=BinaryHeap::from([Reverse((T::default(),start))]);while let Some(Reverse((d,v)))=pq.pop(){if dist[v].as_ref()!=Some(&d){continue;}for(u,c)in&self.adj[v]{let nd=d.clone()+c.clone();if let Some(pd)=&dist[*u]{if pd<=&nd{continue;}}dist[*u]=Some(nd.clone());self.prv[*u]=Some(v);pq.push(Reverse((nd,*u)));}}self.dist=dist;&self.dist}#[must_use]pub fn path(&self,end:usize)->Option<Vec<usize>>{assert!(!self.prv.is_empty(),"run solve(_) first");self.verify_vertex(end);self.dist[end].as_ref()?;let mut path=vec![end];while let Some(v)=path.last(){if let Some(u)=self.prv[*v]{path.push(u);}else{path.reverse();return Some(path);};}unreachable!()}}}
        pub mod edge_list {use std::convert::TryFrom;#[derive(Clone,Debug,Default)]pub struct Edge<T>{pub to:u32,pub content:T,prev:u32,}#[derive(Clone,Debug,Default)]pub struct Graph<T>{heads:Vec<u32>,edges:Vec<Edge<T>>,}impl<T>Graph<T>{#[inline]pub fn new(n:usize)->Self{assert!(n<u32::MAX as usize,"why do you need {} vertices?!",n);Self{heads:vec![u32::MAX;n],edges:vec![],}}#[inline]pub fn vertex_count(&self)->usize{self.heads.len()}#[inline]pub fn edge_count(&self)->usize{self.edges.len()}#[inline]fn verify_vertex(&self,v:usize){debug_assert!(v<self.vertex_count(),"invalid vertex {} on {} vertices",v,self.vertex_count());}#[inline]pub fn direct(&mut self,from:usize,to:usize,content:T)->usize{self.verify_vertex(from);self.verify_vertex(to);let index=u32::try_from(self.edges.len()).unwrap();let prev=std::mem::replace(&mut self.heads[from],index);self.edges.push(Edge{to:to as u32,content,prev,});index as usize}#[inline]pub fn bidirect(&mut self,a:usize,b:usize,content:T)->usize where T:Clone,{let index=self.direct(a,b,content.clone());self.direct(b,a,content);index}#[inline]pub fn edges(&self)->&[Edge<T>]{&self.edges}#[inline]pub fn edges_from(&self,v:usize)->impl Iterator<Item=&Edge<T>>{std::iter::successors(self.edges.get(self.heads[v]as usize),move|edge|{self.edges.get(edge.prev as usize)})}#[inline]pub fn neighbors(&self,v:usize)->impl Iterator<Item=(usize,&T)>+'_{self.edges_from(v).map(|edge|(edge.to as usize,&edge.content))}}pub type UnweightedGraph=Graph<()>;}
        pub mod hungarian {#[derive(Debug,Clone,Default)]pub struct Hungarian{mat:Vec<Vec<i64>>,perm:Vec<usize>,inv_perm:Vec<usize>,u:Vec<i64>,v:Vec<i64>,}impl Hungarian{pub fn solve(mat:Vec<Vec<i64>>)->Self{let mut solver=Self::default();for row in mat{solver.add_row(row);}solver}pub fn height(&self)->usize{self.u.len()}pub fn width(&self)->usize{self.v.len()}pub fn cost(&self)->i64{self.mat.iter().zip(self.perm.iter()).map(|(row,j)|row[*j]).sum::<i64>()}pub fn permutation(&self)->&[usize]{&self.perm}pub fn potentials(&self)->(&[i64],&[i64]){(&self.u,&self.v)}pub fn add_row(&mut self,row:Vec<i64>){let(n,mut m)=(self.height(),self.width());if n==0{m=row.len();self.v=vec![0;m];self.inv_perm=vec![usize::MAX;m+1];}else{assert!(n<=m,"too many rows");assert_eq!(m,row.len(),"matrix must be rectangular");}self.mat.push(row);self.perm.push(0);self.u.push(0);let mut minv=vec![i64::MAX;m];let mut augment=vec![0;m];let mut used=vec![false;m+1];self.inv_perm[m]=n;let mut j_cur=m;loop{let i=self.inv_perm[j_cur];if i==usize::MAX{break;}let row=&self.mat[i];let ui=self.u[i];used[j_cur]=true;let(delta,j_next)=used.iter().zip(row).zip(&self.v).zip(&mut minv).enumerate().filter(|(_,(((used,_),_),_))|!**used).map(|(j,(((_,rj),vj),mvj))|{let diff=*rj-ui-vj;if diff<*mvj{*mvj=diff;augment[j]=j_cur;}(*mvj,j)}).min().unwrap();for j in 0..m{if used[j]{self.u[self.inv_perm[j]]+=delta;self.v[j]-=delta;}else{minv[j]-=delta;}}self.u[n]+=delta;j_cur=j_next;}while j_cur!=m{let j_prev=augment[j_cur];self.inv_perm[j_cur]=self.inv_perm[j_prev];self.perm[self.inv_perm[j_cur]]=j_cur;j_cur=j_prev;}}}}
        pub mod scc {use crate::__cargo_equip::preludes::scc::*;use crate::__cargo_equip::crates::edge_list as edge_list;use edge_list::Graph;use std::convert::TryInto;struct SccProcessor<'a,T>{graph:&'a Graph<T>,up:Vec<u32>,visit:Vec<u32>,scx:Vec<u32>,stack:Vec<u32>,cnt:u32,sccnt:u32,}const NOPE:u32=u32::MAX;impl<'a,T>SccProcessor<'a,T>{fn dfs(&mut self,v:u32){let vs=v as usize;self.up[vs]=self.cnt;self.visit[vs]=self.cnt;self.cnt+=1;self.stack.push(v);for(nxt,_)in self.graph.neighbors(vs){if self.visit[nxt]==NOPE{self.dfs(nxt.try_into().unwrap());self.up[vs]=self.up[vs].min(self.up[nxt]);}else if self.scx[nxt]==NOPE{self.up[vs]=self.up[vs].min(self.visit[nxt]);}}if self.up[vs]==self.visit[vs]{while let Some(t)=self.stack.pop(){self.scx[t as usize]=self.sccnt;if t==v{break;}}self.sccnt+=1;}}}#[derive(Debug,Clone)]pub struct Scc{pub count:usize,pub indices:Vec<u32>,}pub fn make_scc<T>(graph:&Graph<T>)->Scc{let n=graph.vertex_count();let mut me=SccProcessor{graph,up:vec![NOPE;n],visit:vec![NOPE;n],scx:vec![NOPE;n],stack:vec![NOPE;n],cnt:0,sccnt:0,};for v in 0..n{if me.visit[v]==NOPE{me.dfs(v.try_into().unwrap());}}let count=me.sccnt;for idx in&mut me.scx{*idx=count-1-*idx;}Scc{count:count as usize,indices:me.scx,}}impl Scc{pub fn components(&self)->Vec<Vec<usize>>{let mut comps=vec![vec![];self.count];for(v,idx)in self.indices.iter().enumerate(){comps[*idx as usize].push(v);}comps}}}
        pub mod toposort {use crate::__cargo_equip::preludes::toposort::*;use crate::__cargo_equip::crates::edge_list as edge_list;use edge_list::Graph;pub fn toposort<T>(graph:&Graph<T>)->Option<Vec<usize>>{let n=graph.vertex_count();let mut indegs=vec![0;n];for a in 0..n{for(b,_)in graph.neighbors(a){indegs[b]+=1;}}let mut stack=(0..n).filter(|i|indegs[*i]==0).collect::<Vec<_>>();let mut order=stack.clone();while let Some(a)=stack.pop(){for(b,_)in graph.neighbors(a){indegs[b]-=1;if indegs[b]>0{continue;}stack.push(b);order.push(b);}}(order.len()==n).then_some(order)}}
        pub mod tree_compress {use crate::__cargo_equip::preludes::tree_compress::*;use hld::Hld;use crate::__cargo_equip::crates::hld as hld;#[derive(Debug,Clone)]pub struct CompressedTree<'a>{hld:&'a Hld,tree:Vec<Vec<u32>>,used_vertices:Vec<usize>,pub is_target:Vec<bool>,root:Option<usize>,}impl<'a>CompressedTree<'a>{pub fn new(hld:&'a Hld)->Self{let n=hld.len();Self{hld,tree:vec![vec![];n],used_vertices:vec![],is_target:vec![false;n],root:None,}}pub fn clear(&mut self){for v in self.used_vertices.drain(..){self.is_target[v]=false;self.tree[v].clear();}self.root=None;}pub fn compress(&mut self,mut vertices:Vec<usize>)->bool{self.clear();if vertices.is_empty(){return false;}for v in&vertices{self.is_target[*v]=true;}vertices.sort_unstable_by_key(|v|self.hld.index(*v));let intermediates=vertices.windows(2).map(|w|self.hld.lca(w[0],w[1])).collect::<Vec<_>>();vertices.extend(intermediates);vertices.sort_unstable_by_key(|v|self.hld.index(*v));vertices.dedup();self.root=Some(vertices[0]);for w in vertices.windows(2){let par=self.hld.lca(w[0],w[1]);self.tree[par].push(w[1]as u32)}self.used_vertices=vertices;true}pub fn dfs<V>(&mut self,compute:impl Fn(&mut Self,usize,Vec<(usize,V)>)->V+Copy,)->Option<V>{let Some(root)=self.root else{return None;};Some(self.dfs_inner(root,compute))}fn dfs_inner<V>(&mut self,v:usize,compute:impl Fn(&mut Self,usize,Vec<(usize,V)>)->V+Copy,)->V{let mut sons=vec![];for u in self.tree[v].clone(){let val=self.dfs_inner(u as usize,compute);sons.push((u as usize,val));}compute(self,v,sons)}}}
        pub mod hld {use crate::__cargo_equip::preludes::hld::*;use edge_list::Graph;use crate::__cargo_equip::crates::edge_list as edge_list;#[derive(Debug,Clone)]pub struct Hld{parent:Vec<Option<u32>>,size:Vec<u32>,depth:Vec<u32>,heavy_child:Vec<Option<u32>>,top:Vec<u32>,dfs_index:Vec<u32>,}type Range=(usize,usize);impl Hld{pub fn new<T>(tree:&Graph<T>,root:usize)->Self{let n=tree.vertex_count();assert!(root<n);let mut hld=Hld{parent:vec![None;n],size:vec![0;n],depth:vec![0;n],heavy_child:vec![None;n],top:vec![0;n],dfs_index:vec![0;n],};hld.dfs_size(tree,root);hld.top[root]=root as u32;hld.dfs_hld(tree,root,0);hld}fn dfs_size<T>(&mut self,tree:&Graph<T>,v:usize){self.size[v]=1;for(u,_)in tree.neighbors(v){if Some(u as u32)==self.parent[v]{continue;}self.parent[u]=Some(v as u32);self.depth[u]=self.depth[v]+1;self.dfs_size(tree,u);self.size[v]+=self.size[u];if let Some(other_u)=self.heavy_child[v]{if self.size[u]>self.size[other_u as usize]{self.heavy_child[v]=Some(u as u32);}}else{self.heavy_child[v]=Some(u as u32);}}}fn dfs_hld<T>(&mut self,tree:&Graph<T>,v:usize,mut idx:u32)->u32{self.dfs_index[v]=idx;let Some(first_u)=self.heavy_child[v]else{return idx;};self.top[first_u as usize]=self.top[v];idx=self.dfs_hld(tree,first_u as usize,idx+1);for(u,_)in tree.neighbors(v){if u as u32==first_u||Some(u as u32)==self.parent[v]{continue;}self.top[u]=if Some(u as u32)==self.heavy_child[v]{self.top[v]}else{u as u32};idx=self.dfs_hld(tree,u,idx+1);}idx}pub fn len(&self)->usize{self.parent.len()}pub fn depth(&self,v:usize)->u32{self.depth[v]}pub fn index(&self,v:usize)->usize{self.dfs_index[v]as usize}pub fn subtree(&self,v:usize)->Range{let l=self.dfs_index[v]as usize;(l,l+self.size[v]as usize-1)}pub fn path_from_top(&self,v:usize)->Range{let top=self.top[v]as usize;(self.dfs_index[top]as usize,self.dfs_index[v]as usize)}pub fn lca(&self,mut a:usize,mut b:usize)->usize{loop{let ta=self.top[a]as usize;let tb=self.top[b]as usize;if ta==tb{break;}if self.depth[ta]>self.depth[tb]{a=self.parent[ta].unwrap()as usize;}else{b=self.parent[tb].unwrap()as usize;}}if self.dfs_index[a]>self.dfs_index[b]{b}else{a}}pub fn path(&self,mut a:usize,mut b:usize)->(usize,Vec<Range>,Vec<Range>){let mut a_path=vec![];let mut b_path=vec![];loop{let ta=self.top[a]as usize;let tb=self.top[b]as usize;if ta==tb{break;}if self.depth[ta]>self.depth[tb]{a_path.push(self.path_from_top(a));a=self.parent[ta].unwrap()as usize;}else{b_path.push(self.path_from_top(b));b=self.parent[tb].unwrap()as usize;}}let ai=self.dfs_index[a]as usize;let bi=self.dfs_index[b]as usize;if ai>bi{a_path.push((bi,ai));(b,a_path,b_path)}else{b_path.push((ai,bi));(a,a_path,b_path)}}}}
        pub mod io {use std::{fmt::{Debug,Display},io::{self,BufRead as X,BufWriter,Lines,StdinLock,Stdout,Write as Y},iter::Peekable,str::FromStr as F,};pub struct OJ<R:X,W:Y>{lines:Peekable<Lines<R>>,out:W,tokens:Vec<String>,}macro_rules!a{($ty:ident)=>{impl<R:X,W:Y>OJ<R,W>{pub fn$ty(&mut self)->$ty{self.parse()}}};}a!(i32);a!(u32);a!(i64);a!(u64);a!(usize);a!(f64);impl<R:X,W:Y>OJ<R,W>{pub fn new(reader:R,writer:W)->Self{Self{lines:reader.lines().peekable(),out:writer,tokens:vec![],}}pub fn is_eof(&mut self)->bool{self.tokens.is_empty()&&self.lines.peek().is_none()}pub fn line(&mut self)->String{assert!(self.tokens.is_empty(),"please finish the current line");self.lines.next().expect("EOF").unwrap()}pub fn word(&mut self)->String{while self.tokens.is_empty(){self.tokens=self.line().split_whitespace().rev().map(ToString::to_string).collect();}self.tokens.pop().unwrap()}pub fn chars(&mut self)->Vec<char>{self.word().chars().collect()}pub fn parse<T:F>(&mut self)->T where<T as F>::Err:Debug,{self.word().parse().unwrap()}pub fn vec<T:F>(&mut self,n:usize)->Vec<T>where<T as F>::Err:Debug,{(0..n).map(|_|self.parse()).collect()}pub fn write<T:Display>(&mut self,val:T)->&mut Self{write!(self.out,"{val}").unwrap();self}pub fn debug<T:Debug>(&mut self,val:T)->&mut Self{write!(self.out,"{val:?}").unwrap();self}pub fn sp(&mut self)->&mut Self{self.write(' ')}pub fn ln(&mut self)->&mut Self{self.write('\n')}pub fn flush(&mut self)->&mut Self{self.out.flush().unwrap();self}pub fn quit<T:Display>(&mut self,val:T)->!{self.write(val);self.out.flush().unwrap();std::process::exit(0)}}#[must_use]pub fn stdin()->OJ<StdinLock<'static>,BufWriter<Stdout>>{let lock=io::stdin().lock();OJ::new(lock,BufWriter::with_capacity(1<<18,io::stdout()))}}
        pub mod io_short {use std::{fmt::{Debug,Display},io::{self,BufWriter,Read,Stdout,Write},str::FromStr,};pub struct OJ{inp:Vec<String>,out:BufWriter<Stdout>,}macro_rules!a{($ty:ident)=>{impl OJ{pub fn$ty(&mut self)->$ty{self.word().parse().unwrap()}}};}a!(i32);a!(u32);a!(i64);a!(u64);a!(usize);a!(f64);a!(u8);impl OJ{pub fn is_eof(&mut self)->bool{self.inp.is_empty()}pub fn word(&mut self)->String{self.inp.pop().expect("EOF")}pub fn vec<T:FromStr>(&mut self,n:usize)->Vec<T>where<T as FromStr>::Err:Debug,{(0..n).map(|_|self.word().parse().unwrap()).collect()}pub fn write<T:Display>(&mut self,val:T)->&mut Self{write!(self.out,"{val}").unwrap();self}pub fn debug<T:Debug>(&mut self,val:T)->&mut Self{write!(self.out,"{val:?}").unwrap();self}pub fn sp(&mut self)->&mut Self{self.write(' ')}pub fn ln(&mut self)->&mut Self{self.write('\n')}}pub fn stdin()->OJ{let mut input=String::new();io::stdin().read_to_string(&mut input).unwrap();OJ{inp:input.split_whitespace().rev().map(|s|s.to_owned()).collect(),out:BufWriter::with_capacity(1<<18,io::stdout()),}}}
        pub mod enum_comb {use std::ops::*;pub fn partition_number<T>(n:usize)->Vec<T>where T:From<u32>+Clone+AddAssign+SubAssign,{let mut p=vec![T::from(1)];for i in 1..=n{let mut ans=T::from(0);for k in 1..{let Some(j)=i.checked_sub(k*(3*k-1)/2)else{break;};if k%2==1{ans+=p[j].clone();}else{ans-=p[j].clone();}let Some(j)=j.checked_sub(k)else{break;};if k%2==1{ans+=p[j].clone();}else{ans-=p[j].clone();}}p.push(ans);}p}}
        pub mod gcd {pub trait Gcd{#[must_use]fn gcd(self,other:Self)->Self;}pub trait Lcm{#[must_use]fn lcm(self,other:Self)->Self;}macro_rules!impl_gcd_lcm{($($T:ty)*)=>{$(impl Gcd for$T{fn gcd(self,b:Self)->Self{if self==0||b==0{return self|b;}let(mut a,mut b)=(self,b);let gcd_exponent_on_two=(a|b).trailing_zeros();a>>=a.trailing_zeros();b>>=b.trailing_zeros();while a!=b{if a<b{core::mem::swap(&mut a,&mut b);}a-=b;a>>=a.trailing_zeros();}a<<gcd_exponent_on_two}}impl Lcm for$T{fn lcm(self,b:Self)->Self{if b==0{0}else{self/self.gcd(b)*b}}})*};}impl_gcd_lcm!(u8 u16 u32 u64 u128 usize);}
        pub mod kth_root {pub trait KthRoot:Sized{fn kth_root(&self,k:u32)->Result<Self,Self>;#[must_use]fn ceil_kth_root(&self,k:u32)->Self;#[must_use]fn floor_kth_root(&self,k:u32)->Self{match self.kth_root(k){Ok(v)|Err(v)=>v,}}}macro_rules!impl_kth_root{($($T:ty)*)=>{$(impl KthRoot for$T{fn kth_root(&self,k:u32)->Result<Self,Self>{use std::cmp::Ordering;assert_ne!(k,0);if*self<=1||k==1{return Ok(*self);}let mut f=((*self as f64).powf(1./k as f64)as Self).saturating_sub(1);while let Some(v)=(f+1).checked_pow(k){match v.cmp(self){Ordering::Less=>{f+=1;}Ordering::Equal=>{return Ok(f+1);}Ordering::Greater=>{return Err(f);}}}Err(f)}fn ceil_kth_root(&self,k:u32)->Self{match self.kth_root(k){Ok(v)=>v,Err(v)=>v+1,}}})*}}impl_kth_root!(u8 u16 u32 u64 u128);}
        pub mod modpow {pub fn modpow_generic<T:Clone>(a:T,mut b:u64,initial:T,multiply:impl Fn(&mut T,&T))->T{let mut ans=initial;let mut mul=a;while b!=0{if b&1==1{multiply(&mut ans,&mul);}let mul_self=mul.clone();multiply(&mut mul,&mul_self);b>>=1;}ans}pub fn modpow_u64(a:u64,b:u64,md:u64)->u64{modpow_generic(a,b,1%md,|x,a|{*x=*x**a%md;})}}
        pub mod psuedo_rand {pub struct Rng32([u32;4]);impl Rng32{pub fn split_mix(v:u32)->u32{let mut z=v.wrapping_add(0x9e3779b9);z=(z^(z>>15)).wrapping_mul(0x85ebca6b);z=(z^(z>>13)).wrapping_mul(0xc2b2ae35);z^(z>>16)}pub fn new()->Self{let mut seed=0;unsafe{std::arch::x86_64::_rdrand32_step(&mut seed)};let mut prev=seed;Self(std::array::from_fn(|_|{prev=Self::split_mix(prev);prev}))}pub fn next(&mut self,n:u32)->u32{let[x,y,z,w]=&mut self.0;let res=x.wrapping_add(*w);let t=x.wrapping_shl(9);*y^=*x;*w^=*y;*y^=*z;*x^=*w;*z^=t;*w=w.rotate_left(11);((res as u64*n as u64)>>32)as u32}}pub struct Rng64([u64;4]);impl Rng64{pub fn split_mix(v:u64)->u64{let mut z=v.wrapping_add(0x9e3779b97f4a7c15);z=(z^(z>>30)).wrapping_mul(0xbf58476d1ce4e5b9);z=(z^(z>>27)).wrapping_mul(0x94d049bb133111eb);z^(z>>31)}pub fn new()->Self{let mut seed=0;unsafe{std::arch::x86_64::_rdrand64_step(&mut seed)};let mut prev=seed;Self(std::array::from_fn(|_|{prev=Self::split_mix(prev);prev}))}pub fn next(&mut self,n:u64)->u64{let[x,y,z,w]=&mut self.0;let res=x.wrapping_add(*w);let t=x.wrapping_shl(17);*y^=*x;*w^=*y;*y^=*z;*x^=*w;*z^=t;*w=w.rotate_left(45);((res as u128*n as u128)>>64)as u64}pub fn shuffle<T>(&mut self,a:&mut[T]){let mut i=a.len();while i>1{i-=1;let bound=(i as u64).wrapping_add(1);let j=self.next(bound)as usize;a.swap(i,j);}}}}
        pub mod sieve {pub fn general_sieve<T>(n:usize,initial:impl Fn(usize)->T,check:impl Fn(usize,&T)->bool,update:impl Fn(&mut[T],usize,usize),)->Vec<T>{let mut sieve=(0..=n).map(initial).collect::<Vec<_>>();for p in 1..=n{if!check(p,&sieve[p]){continue;}for q in(p..=n).step_by(p){update(&mut sieve,p,q);}}sieve}pub fn prime_sieve(n:usize)->Vec<bool>{general_sieve(n,|i|(i>=2),|_,&x|x,|sieve,p,q|{sieve[q]=p==q;},)}pub fn phi_sieve(n:usize)->Vec<usize>{general_sieve(n,|i|i,|p,x|p>1&&*x==p,|arr,p,q|{arr[q]-=arr[q]/p;},)}}
        pub mod bigint {#[derive(Clone,PartialEq,Eq)]pub struct BigInt(bool,Vec<u64>);impl std::str::FromStr for BigInt{type Err=std::convert::Infallible;fn from_str(mut s:&str)->std::result::Result<Self,Self::Err>{let sign=s.starts_with("-");if sign{s=&s[1..];}let size=(s.len()+RADIX_POW-1)/RADIX_POW;let mut v=Vec::with_capacity(size);for c in s.as_bytes().rchunks(RADIX_POW){let mut t=0;for&b in c{t*=10;t+=(b-b'0')as u64;}v.push(t);}Ok(Self(sign,v))}}impl std::fmt::Display for BigInt{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{if self.0{write!(f,"-")?;}let mut a=self.1.iter().rev();let last=*a.next().unwrap();write!(f,"{last}")?;for l in a{write!(f,"{l:00$}",RADIX_POW)?;}Ok(())}}impl std::cmp::PartialOrd for BigInt{fn partial_cmp(&self,other:&Self)->Option<std::cmp::Ordering>{Some(self.cmp(other))}}impl std::cmp::Ord for BigInt{fn cmp(&self,other:&Self)->std::cmp::Ordering{use std::cmp::Ordering::*;if self.0&&!other.0{Less}else if!self.0&&other.0{Greater}else{let ord=if self.1.len()!=other.1.len(){self.1.len().cmp(&other.1.len())}else{let mut last=Equal;for(l,r)in self.1.iter().rev().zip(other.1.iter().rev()){last=l.cmp(r);if last!=Equal{break;}}last};if self.0{match ord{Less=>Greater,Equal=>Equal,Greater=>Less,}}else{ord}}}}const RADIX:u64=1_000_000;const RADIX_POW:usize=6;impl BigInt{pub fn new()->Self{Self(false,vec![0])}pub fn is_zero(&self)->bool{self.1.len()==1&&self.1[0]==0}pub fn normalize(&mut self){let len=self.1.iter().rposition(|&l|l!=0).unwrap_or(0)+1;self.1.truncate(len);if self.1.len()==1&&self.1[0]==0{self.0=false;}}pub fn add(&mut self,rhs:&Self){if self.0==rhs.0{self.unsigned_add_assign(rhs);}else{self.unsigned_sub_assign(rhs);}}pub fn sub(&mut self,rhs:&Self){if self.0==rhs.0{self.unsigned_sub_assign(rhs);}else{self.unsigned_add_assign(rhs);}}pub fn divmod_scalar(&mut self,rhs:u64)->u64{let mut borrow=0;for d in self.1.iter_mut().rev(){borrow*=RADIX;borrow+=*d;(*d,borrow)=(borrow/rhs,borrow%rhs);}self.normalize();borrow}pub fn mul(&mut self,rhs:&Self){const NTT_0_INV:u64=285212675;let pad=(self.1.len()+rhs.1.len()-1).next_power_of_two();self.1.resize(pad,0);let mut l=&mut self.1;let mut r=vec![0;pad];r[..rhs.1.len()].copy_from_slice(&rhs.1);let mut l1=l.clone();let mut r1=r.clone();NTT[0].run(&mut l,false);NTT[0].run(&mut r,false);for(l,r)in l.iter_mut().zip(r){*l=NTT[0].m.rem(*l as u64*r as u64);}NTT[0].run(&mut l,true);NTT[1].run(&mut l1,false);NTT[1].run(&mut r1,false);for(l,r)in l1.iter_mut().zip(r1){*l=NTT[1].m.rem(*l as u64*r as u64);}NTT[1].run(&mut l1,true);for(l,l1)in l.iter_mut().zip(l1){let r=NTT[1].m.rem((l1+NTT[1].m.1-*l)*NTT_0_INV);*l+=NTT[0].m.1*r;}let mut carry=0;for x in l{*x+=carry;carry=*x/RADIX;*x%=RADIX;}while carry>0{self.1.push(carry%RADIX);carry/=RADIX;}self.0=self.0!=rhs.0;self.normalize();}pub fn unsigned_add_assign(&mut self,rhs:&Self){if rhs.is_zero(){return;}else if self.is_zero(){self.0=rhs.0;self.1=rhs.1.clone();return;}let n=self.1.len().min(rhs.1.len());let mut carry=0;for(l,&r)in self.1[..n].iter_mut().zip(&rhs.1){*l+=r;*l+=carry;if*l>=RADIX{*l-=RADIX;carry=1;}else{carry=0;}}for l in&mut self.1[n..]{*l+=carry;if*l>=RADIX{*l-=RADIX;carry=1;}else{carry=0;break;}}for&r in&rhs.1[n..]{let mut l=r+carry;if l>=RADIX{l-=RADIX;carry=1;}else{carry=0;}self.1.push(l);}if carry>0{self.1.push(1);}self.normalize();}pub fn unsigned_sub_assign(&mut self,rhs:&Self){if rhs.is_zero(){return;}else if self.is_zero(){self.0=!rhs.0;self.1=rhs.1.clone();return;}let less=self.1.len().saturating_sub(rhs.1.len());let mut a=self.1.iter_mut();let mut b=rhs.1.iter().chain(std::iter::repeat(&0).take(less));let mut zero=true;let mut carry=0;for(l,&r)in a.by_ref().zip(b.by_ref()){if zero{if r!=0{zero=false;*l+=RADIX-r;}else{continue;}}else{*l+=RADIX-1+carry-r;}if*l>=RADIX{*l-=RADIX;carry=1;}else{carry=0;}}for&r in b{let mut add;if zero{if r!=0{zero=false;add=RADIX+carry-r;}else{continue;}}else{add=RADIX-1+carry-r;}if add>=RADIX{add-=RADIX;carry=1;}else{carry=0;}self.1.push(add);}if carry==0{self.0=!self.0;let mut a=self.1.iter_mut().skip_while(|v|**v==0);if let Some(first)=a.next(){*first=RADIX-*first;for v in a{*v=RADIX-1-*v;}}}self.normalize();}}pub struct NttParam{m:ModU64,u:u64,ui:u64,s:u32,}static NTT:&[NttParam]=&[NttParam{m:ModU64::new(1107296257),u:1087287097,ui:623044540,s:25,},NttParam{m:ModU64::new(1711276033),u:969788637,ui:1790856,s:25,},];impl NttParam{pub fn run(&self,a:&mut[u64],inv:bool){let n=a.len();if n==1{return;}let s=n.leading_zeros()+1;for i in 0..n{let r=i.reverse_bits()>>s;if i<r{a.swap(i,r);}}let u=if inv{self.ui}else{self.u};for k in 1..=n.trailing_zeros(){let mut wlen=u;for _ in k..self.s{wlen=self.m.rem(wlen*wlen);}let kh=1<<(k-1);for i in 0..(n+(1<<k)-1)>>k{let i=i<<k;let mut w=1;for j in 0..kh{let u=a[i+j];let v=self.m.rem(a[i+j+kh]*w);let mut s=u+v;if s>=self.m.1{s-=self.m.1;}a[i+j]=s;let mut d=u+self.m.1-v;if d>=self.m.1{d-=self.m.1;}a[i+j+kh]=d;w=self.m.rem(w*wlen);}}}if inv{let p=self.m.1 as i64;let ni=((egcd(n as i64,p).1%p+p)%p)as u64;for x in a{*x=self.m.rem(*x as u64*ni);}}}}pub fn egcd(mut a:i64,mut b:i64)->(i64,i64,i64){let(mut x,mut y,mut x1,mut y1)=(1,0,0,1);while b!=0{let q=a/b;(x,x1)=(x1,x-q*x1);(y,y1)=(y1,y-q*y1);(a,b)=(b,a-q*b);}(a,x,y)}#[derive(Copy,Clone)]pub struct ModU64(u128,u64);impl ModU64{pub const fn new(div:u64)->Self{Self((!0u128/div as u128).wrapping_add(1),div)}pub fn multop(a:u128,b:u64)->u64{let mut bottom=(a as u64 as u128)*b as u128;bottom>>=64;let top=(a>>64)*b as u128;((bottom+top)>>64)as u64}pub fn rem(&self,a:u64)->u64{let low=self.0.wrapping_mul(a as u128);Self::multop(low,self.1)}}}
        pub mod binary_search {pub trait BinSearch:Sized{fn binary_search_min<F:Fn(&Self)->bool>(pred:F,lo:Self,hi:Self)->Option<Self>;}impl BinSearch for i64{fn binary_search_min<F:Fn(&Self)->bool>(pred:F,mut lo:Self,mut hi:Self,)->Option<Self>{let mut ans=None;while lo<=hi{let mid=(lo+hi)/2;if pred(&mid){ans=Some(mid);hi=mid-1;}else{lo=mid+1;}}ans}}}
        pub mod bit_helper {pub trait BitHelper:Sized{fn bit_is_one(&self,b:u32)->bool;fn one_bits(&self)->Vec<u32>;fn first_bit_perm(ones:u32)->Self;fn next_bit_perm(&self)->Option<Self>;fn bit_perms(digits:u32,ones:u32)->Box<dyn Iterator<Item=Self>>;}macro_rules!impl_bit_perm{($($T:ty)*)=>{$(impl BitHelper for$T{fn bit_is_one(&self,b:u32)->bool{self&(1<<b)!=0}fn one_bits(&self)->Vec<u32>{(0..Self::BITS).filter(|b|self.bit_is_one(*b)).collect()}fn first_bit_perm(ones:u32)->Self{assert!(ones<=Self::BITS,"called first_bit_perm with {} ones",ones);if ones==Self::BITS{return Self::MAX;}(1<<ones)-1}fn next_bit_perm(&self)->Option<Self>{let t=self|(self-1);if t==Self::MAX{return None;}let z=(!t&(t+1))-1;let z=z>>(self.trailing_zeros()+1);Some((t+1)|z)}fn bit_perms(digits:u32,ones:u32)->Box<dyn Iterator<Item=Self>>{assert!(ones<=digits);assert!(digits<=Self::BITS);let first=Self::first_bit_perm(ones);if ones==0{return Box::new(std::iter::once(first));}let last=first<<(digits-ones);if digits==ones{return Box::new(std::iter::once(first));}let it=std::iter::successors(Some(first),|v|v.next_bit_perm()).take_while(move|v|v<=&last);Box::new(it)}})*};}impl_bit_perm!(u8 u16 u32 u64 u128 usize);}
        pub mod calendar {pub fn is_leap_year(y:u32)->bool{y%(if y%25==0{16}else{4})==0}pub fn last_day_of_month(y:u32,m:u8)->u8{assert!((1..=12).contains(&m),"{}",m);if m==2{if is_leap_year(y){29}else{28}}else{[0,31,0,31,30,31,30,31,31,30,31,30,31][m as usize]}}pub fn is_valid_date(y:u32,m:u8,d:u8)->bool{(1..=12).contains(&m)&&0<d&&d<=last_day_of_month(y,m)}}
        pub mod dnc_opt {use std::cmp::Reverse;pub fn min_dnc_opt<T>(f:impl Fn(usize,usize)->Option<T>,n:usize,m:usize)->Vec<T>where T:Clone+Default+Ord,{assert!(m>0);if n==0{return vec![];}let mut ans=vec![T::default();n];let mut task=vec![(0,n-1,0,m-1)];while let Some((imin,imax,jmin,jmax))=task.pop(){let mid=(imin+imax)/2;let(opt_val,Reverse(opt_j))=(jmin..=jmax).filter_map(|j|f(mid,j).map(|val|(val,Reverse(j)))).min().unwrap();ans[mid]=opt_val;if imin<mid{task.push((imin,mid-1,jmin,opt_j));}if mid<imax{task.push((mid+1,imax,opt_j,jmax));}}ans}pub fn min_plus_convolution<T>(convex:&[T],other:&[T])->Vec<T>where T:std::ops::Add<Output=T>+Default+Clone+Ord,{let n=convex.len();let m=other.len();if n==0||m==0{return vec![];}assert!(convex.windows(3).all(|w|{w[2].clone()+w[0].clone()>=w[1].clone()+w[1].clone()}));min_dnc_opt(|i,j|{if i<j||i-j>=n{return None;}Some(convex[i-j].clone()+other[j].clone())},n+m-1,m,)}pub fn max_plus_convolution<T>(concave:&[T],other:&[T])->Vec<T>where T:std::ops::Add<Output=T>+Default+Clone+Ord,{let n=concave.len();let m=other.len();if n==0||m==0{return vec![];}assert!(concave.windows(3).all(|w|{w[2].clone()+w[0].clone()<=w[1].clone()+w[1].clone()}));min_dnc_opt(|i,j|{if i<j||i-j>=n{return None;}Some(Reverse(concave[i-j].clone()+other[j].clone()))},n+m-1,m,).into_iter().map(|Reverse(v)|v).collect()}}
        pub mod gadgets {#[allow(dead_code)]fn count_mod_in_range(l:u64,r:u64,x:u64,md:u64)->u64{assert_ne!(md,0);if x>=md||l>r{return 0;}let mut ans=r/md+(r%md>=x)as u64;if l>0{ans-=(l-1)/md+((l-1)%md>=x)as u64;}ans}#[allow(dead_code)]fn digits_rtol(n:u64)->impl Iterator<Item=u64>{std::iter::successors(Some(n),|i|Some(*i/10)).take_while(|i|*i>0).map(|i|i%10)}#[allow(dead_code)]fn is_subsequence<T:PartialEq>(small:impl Iterator<Item=T>,mut large:impl Iterator<Item=T>,)->bool{for x in small{if!large.any(|y|x==y){return false;}}true}}
        pub mod lis {use std::cmp::Ordering;pub fn lis<T:Ord>(list:&[T])->Vec<usize>{lis_by(list,T::cmp)}pub fn lis_by<T,F>(list:&[T],compare:F)->Vec<usize>where F:Fn(&T,&T)->Ordering,{if list.is_empty(){return vec![];}let n=list.len();let mut prev=Vec::<usize>::with_capacity(n);let mut optimal_ends=vec![];for(i,x)in list.iter().enumerate(){let prev_i=optimal_ends.partition_point(|j|compare(x,&list[*j]).is_gt());if prev_i==0{prev.push(0);}else{prev.push(optimal_ends[prev_i-1]);}if prev_i==optimal_ends.len(){optimal_ends.push(i);}else{optimal_ends[prev_i]=i;}}let mut lis=optimal_ends;let mut i=*lis.last().unwrap();for x in lis.iter_mut().rev(){*x=i;i=prev[i];}lis}pub fn lis_by_key<T,F,K>(list:&[T],f:F)->Vec<usize>where F:Fn(&T)->K,K:Ord,{let keys=list.iter().map(f).collect::<Vec<_>>();lis(&keys)}}
        pub mod two_sat {use crate::__cargo_equip::preludes::two_sat::*;use crate::__cargo_equip::crates::edge_list as edge_list;use crate::__cargo_equip::crates::scc as scc;use std::fmt::Debug;use edge_list::UnweightedGraph;use scc::make_scc;#[derive(Clone,Debug)]pub struct TwoSat{graph:UnweightedGraph,}impl TwoSat{#[inline]pub fn new(var_count:usize)->Self{Self{graph:UnweightedGraph::new(var_count*2),}}#[inline]pub fn num_vars(&self)->usize{self.graph.vertex_count()>>1}#[inline]fn var(v:usize,sign:bool)->usize{v*2+(sign as usize)}#[inline]pub fn clause(&mut self,x:usize,sign_x:bool,y:usize,sign_y:bool){self.graph.direct(Self::var(x,!sign_x),Self::var(y,sign_y),());self.graph.direct(Self::var(y,!sign_y),Self::var(x,sign_x),());}#[inline]pub fn if_then(&mut self,x:usize,sign_x:bool,y:usize,sign_y:bool){self.clause(x,!sign_x,y,sign_y)}#[inline]pub fn not_both(&mut self,x:usize,sign_x:bool,y:usize,sign_y:bool){self.clause(x,!sign_x,y,!sign_y)}pub fn is_satisfiable(&self)->bool{make_scc(&self.graph).indices.chunks(2).all(|c|c[0]!=c[1])}pub fn solution(&self)->Option<Vec<bool>>{let scc=make_scc(&self.graph);if scc.indices.chunks(2).any(|c|c[0]==c[1]){return None;}let mut sol=vec![None;self.num_vars()];for component in scc.components(){for lit in component{let id=lit>>1;if sol[id].is_some(){continue;}sol[id]=Some(lit&1==0);}}Some(sol.into_iter().map(|b|b.unwrap()).collect())}}}
        pub mod fraction {use crate::__cargo_equip::preludes::fraction::*;use std::{cmp::Ordering,convert::TryFrom,fmt::{Debug,Display},ops::*,str::FromStr,};use crate::__cargo_equip::crates::gcd as gcd;use gcd::Gcd;#[derive(Copy,Clone)]pub struct Frac64{numer:i64,denom:u64,}impl Display for Frac64{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{write!(f,"{}/{}",self.numer,self.denom)}}impl Debug for Frac64{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{write!(f,"{self}")}}impl Default for Frac64{fn default()->Self{Self{numer:0,denom:1}}}impl From<i64>for Frac64{fn from(n:i64)->Self{Self{numer:n,denom:1}}}impl From<Frac64>for f64{fn from(f:Frac64)->Self{(f.numer as f64)/(f.denom as f64)}}impl TryFrom<Frac64>for i64{type Error=();fn try_from(f:Frac64)->Result<Self,Self::Error>{let(num,den)=(f.numer,f.denom as i64);if num%den!=0{return Err(());}Ok(num/den)}}impl FromStr for Frac64{type Err=();fn from_str(s:&str)->Result<Self,Self::Err>{let mut split=s.split('/');let Some(numer)=split.next()else{return Err(());};let Ok(numer)=numer.parse()else{return Err(());};let Some(denom)=split.next()else{return Ok(Self{numer,denom:1});};let Ok(denom)=denom.parse()else{return Err(());};if split.next().is_some(){return Err(());}Ok(Self::new(numer,denom))}}impl PartialEq for Frac64{fn eq(&self,other:&Self)->bool{(self.numer as i128)*(other.denom as i128)==(other.numer as i128)*(self.denom as i128)}}impl Eq for Frac64{}impl PartialOrd for Frac64{fn partial_cmp(&self,other:&Self)->Option<Ordering>{Some(self.cmp(other))}}impl Ord for Frac64{fn cmp(&self,other:&Self)->Ordering{let left=(self.numer as i128)*(other.denom as i128);let right=(other.numer as i128)*(self.denom as i128);left.cmp(&right)}}impl Neg for Frac64{type Output=Self;fn neg(self)->Self::Output{Self{numer:-self.numer,denom:self.denom,}}}impl Add for Frac64{type Output=Self;fn add(self,rhs:Self)->Self::Output{let(a,b)=(self.numer,self.denom);let(c,d)=(rhs.numer,rhs.denom);if b==d{return Self{numer:a+c,denom:b,};}if b>d&&b%d==0{return Self{numer:c*((b/d)as i64)+a,denom:b,};}if d>b&&d%b==0{return Self{numer:a*((d/b)as i64)+c,denom:d,};}Self{numer:a*(d as i64)+c*(b as i64),denom:b*d,}}}impl AddAssign for Frac64{fn add_assign(&mut self,rhs:Self){*self=*self+rhs;}}impl Sub for Frac64{type Output=Self;fn sub(self,rhs:Self)->Self::Output{self+(-rhs)}}impl SubAssign for Frac64{fn sub_assign(&mut self,rhs:Self){*self=*self-rhs;}}impl Mul for Frac64{type Output=Self;fn mul(self,rhs:Self)->Self::Output{Self{numer:self.numer*rhs.numer,denom:self.denom*rhs.denom,}}}impl MulAssign for Frac64{fn mul_assign(&mut self,rhs:Self){*self=*self*rhs;}}impl Div for Frac64{type Output=Self;#[allow(clippy::suspicious_arithmetic_impl)]fn div(self,rhs:Self)->Self::Output{self*rhs.inverse()}}impl DivAssign for Frac64{fn div_assign(&mut self,rhs:Self){*self=*self/rhs;}}impl Frac64{pub fn new(numer:i64,denom:i64)->Self{assert_ne!(denom,0);if denom<0{Self{numer:-numer,denom:(-denom)as u64,}}else{Self{numer,denom:denom as u64,}}}pub fn numer(&self)->i64{self.numer}pub fn denom(&self)->u64{self.denom}pub fn inverse(&self)->Self{Self::new(self.denom as i64,self.numer)}fn gcd(&self)->u64{self.numer.unsigned_abs().gcd(self.denom)}pub fn is_irreducible(&self)->bool{self.gcd()==1}pub fn reduce(&mut self){let g=self.gcd();self.numer/=g as i64;self.denom/=g;}pub fn reduced(mut self)->Self{self.reduce();self}}}
        pub mod harmonic_lemma {use crate::__cargo_equip::preludes::harmonic_lemma::*;pub trait HarmonicLemma{fn divisors(self)->Vec<u128>;}fn isqrt(n:u128)->u128{if n<2{return n;}let mut lo=1u128;let mut hi=n.min(1u128<<64);while lo+1<hi{let mid=(lo+hi)/2;match mid.checked_mul(mid){Some(sq)if sq<=n=>lo=mid,_=>hi=mid,}}lo}fn divisors_u128(n:u128)->Vec<u128>{if n==0{return Vec::new();}let lim=isqrt(n);let mut v=Vec::with_capacity((lim as usize)*2);let mut d=1u128;while d<=lim{if n%d==0{v.push(d);let q=n/d;if q!=d{v.push(q);}}d+=1;}v.sort_unstable();v}fn abs_to_u128_i128(n:i128)->u128{if n>=0{n as u128}else{(-(n+1))as u128+1}}macro_rules!impl_for_unsigned{($($t:ty),*$(,)?)=>{$(impl HarmonicLemma for$t{fn divisors(self)->Vec<u128>{divisors_u128(self as u128)}})*};}macro_rules!impl_for_signed{($($t:ty),*$(,)?)=>{$(impl HarmonicLemma for$t{fn divisors(self)->Vec<u128>{let n_i128=self as i128;divisors_u128(abs_to_u128_i128(n_i128))}})*};}impl_for_unsigned!(u8,u16,u32,u64,u128,usize);impl_for_signed!(i8,i16,i32,i64,i128,isize);}
        pub mod modfact {use crate::__cargo_equip::preludes::modfact::*;use std::ops::Index;use modint::Modint;use crate::__cargo_equip::crates::modint as modint;#[derive(Clone,Debug)]pub struct Modfact<const MOD:u32>{pub fact:Vec<Modint<MOD>>,pub ifact:Vec<Modint<MOD>>,}pub type Modfact17=Modfact<1000000007>;pub type Modfact99=Modfact<998244353>;impl<const MOD:u32>Index<usize>for Modfact<MOD>{type Output=Modint<MOD>;fn index(&self,index:usize)->&Self::Output{&self.fact[index]}}impl<const MOD:u32>Modfact<MOD>{pub fn new(n:usize)->Self{let mut fact=vec![Modint::<MOD>::from(1u32);n+1];let mut ifact=vec![Modint::<MOD>::from(1u32);n+1];for i in 2..=n{fact[i]=fact[i-1]*(i.into());}ifact[n]=fact[n].inv();for i in(2..n).rev(){ifact[i]=ifact[i+1]*((i+1).into());}Self{fact,ifact}}pub fn binom(&self,n:usize,r:usize)->Modint<MOD>{if n<r{return Modint::default();};self[n]*self.ifact[r]*self.ifact[n-r]}pub fn inv(&self,i:usize)->Modint<MOD>{assert!(i>0);self.fact[i-1]*self.ifact[i]}}}
        pub mod modint {use std::{fmt::*,ops::*};#[derive(Default,Debug,Copy,Clone,Eq,PartialEq,Ord,PartialOrd)]pub struct Modint<const MOD:u32>(u32);pub type Modint17=Modint<1000000007>;pub type Modint99=Modint<998244353>;impl<const MOD:u32>Modint<MOD>{pub const fn new(n:u32)->Self{Self(n%MOD)}#[must_use]pub const fn inner(&self)->u32{self.0}#[must_use]pub fn pow(&self,mut n:u64)->Self{let mut ans=Self::from(1u32);let mut a=*self;while n!=0{if n&1==1{ans*=a;}n>>=1;a*=a;}ans}#[must_use]pub fn inv(&self)->Self{assert!(self.0!=0,"Cannot invert 0");self.pow((MOD as u64)-2)}pub fn factorial(n:u32)->Self{let mut ans=Self::from(1u32);for i in 2..=n{ans*=i.into();}ans}}impl<const MOD:u32>std::str::FromStr for Modint<MOD>{type Err=std::num::ParseIntError;fn from_str(s:&str)->std::result::Result<Self,Self::Err>{Ok(Self::from(s.parse::<i64>()?))}}impl<const MOD:u32>Display for Modint<MOD>{fn fmt(&self,f:&mut Formatter)->Result{write!(f,"{}",self.0)}}impl<const MOD:u32>From<Modint<MOD>>for u32{fn from(num:Modint<MOD>)->Self{num.0}}impl<const MOD:u32>From<u32>for Modint<MOD>{fn from(num:u32)->Self{Self(num.rem_euclid(MOD))}}impl<const MOD:u32>From<i32>for Modint<MOD>{fn from(num:i32)->Self{Self(num.rem_euclid(MOD as i32)as u32)}}impl<const MOD:u32>From<i64>for Modint<MOD>{fn from(num:i64)->Self{Self(num.rem_euclid(MOD as i64)as u32)}}impl<const MOD:u32>From<u64>for Modint<MOD>{fn from(num:u64)->Self{Self(num.rem_euclid(MOD as u64)as u32)}}impl<const MOD:u32>From<usize>for Modint<MOD>{fn from(num:usize)->Self{Self(num.rem_euclid(MOD as usize)as u32)}}impl<const MOD:u32>Neg for Modint<MOD>{type Output=Self;fn neg(self)->Self{Self(MOD-self.0)}}impl<const MOD:u32>AddAssign for Modint<MOD>{fn add_assign(&mut self,b:Self){self.0+=b.0;if self.0>=MOD{self.0-=MOD;}}}impl<const MOD:u32>Add for Modint<MOD>{type Output=Self;fn add(self,b:Self)->Self{let mut z=self;z+=b;z}}impl<const MOD:u32>SubAssign for Modint<MOD>{fn sub_assign(&mut self,b:Self){*self+=-b;}}impl<const MOD:u32>Sub for Modint<MOD>{type Output=Self;fn sub(self,b:Self)->Self{let mut z=self;z-=b;z}}impl<const MOD:u32>MulAssign for Modint<MOD>{fn mul_assign(&mut self,b:Self){*self=*self*b;}}impl<const MOD:u32>Mul for Modint<MOD>{type Output=Self;fn mul(self,b:Self)->Self{let val=u64::from(self.0)*u64::from(b.0)%u64::from(MOD);Self::from(val as u32)}}impl<const MOD:u32>DivAssign for Modint<MOD>{fn div_assign(&mut self,b:Self){*self=*self/b;}}#[allow(clippy::suspicious_arithmetic_impl)]impl<const MOD:u32>Div for Modint<MOD>{type Output=Self;fn div(self,b:Self)->Self{self*b.inv()}}}
        pub mod ord_f64 {use std::{cmp::Ordering,fmt,ops::*};#[derive(Clone,Copy,Debug,PartialEq)]pub struct OrdF64(pub f64);impl fmt::Display for OrdF64{#[inline]fn fmt(&self,f:&mut fmt::Formatter<'_>)->fmt::Result{write!(f,"{}",self.0)}}impl Deref for OrdF64{type Target=f64;#[inline]fn deref(&self)->&Self::Target{&self.0}}impl DerefMut for OrdF64{#[inline]fn deref_mut(&mut self)->&mut Self::Target{&mut self.0}}impl Eq for OrdF64{}impl PartialOrd for OrdF64{#[inline]fn partial_cmp(&self,other:&Self)->Option<Ordering>{Some(self.cmp(other))}}impl Ord for OrdF64{#[inline]fn cmp(&self,other:&Self)->Ordering{self.0.partial_cmp(&other.0).unwrap()}}impl Add for OrdF64{type Output=Self;#[inline]fn add(self,rhs:Self)->Self{Self(self.0+rhs.0)}}impl AddAssign for OrdF64{#[inline]fn add_assign(&mut self,rhs:Self){self.0+=rhs.0;}}impl Sub for OrdF64{type Output=Self;#[inline]fn sub(self,rhs:Self)->Self{Self(self.0-rhs.0)}}impl SubAssign for OrdF64{#[inline]fn sub_assign(&mut self,rhs:Self){self.0-=rhs.0;}}impl Mul for OrdF64{type Output=Self;#[inline]fn mul(self,rhs:Self)->Self{Self(self.0*rhs.0)}}impl MulAssign for OrdF64{#[inline]fn mul_assign(&mut self,rhs:Self){self.0*=rhs.0;}}impl Div for OrdF64{type Output=Self;#[inline]fn div(self,rhs:Self)->Self{Self(self.0/rhs.0)}}impl DivAssign for OrdF64{#[inline]fn div_assign(&mut self,rhs:Self){self.0/=rhs.0;}}impl Neg for OrdF64{type Output=Self;#[inline]fn neg(self)->Self{Self(-self.0)}}}
        pub mod factorization {use crate::__cargo_equip::preludes::factorization::*;use crate::__cargo_equip::crates::gcd as gcd;use crate::__cargo_equip::crates::primality as primality;use gcd::Gcd;use primality::is_prime;fn f(a:u64,step:u64,m:u64)->u64{use std::convert::TryInto;((u128::from(a).pow(2)+u128::from(step))%u128::from(m)).try_into().unwrap()}#[must_use]pub fn find_nontrivial_divisor(n:u64)->Option<u64>{if n<=1||is_prime(n){return None;}if n%2==0{return Some(2);}for step in 1..{let mut x=step;let mut y=f(x,step,n);loop{let g=x.abs_diff(y).gcd(n);if g==0||g==n{break;}if g!=1{return Some(g);}x=f(x,step,n);y=f(f(y,step,n),step,n);}}unreachable!()}#[must_use]pub fn factorize(n:u64)->Vec<u64>{if n<=1{return vec![];}let mut ans=vec![];let mut stack=vec![n];while let Some(n)=stack.pop(){if let Some(d)=find_nontrivial_divisor(n){stack.extend([d,n/d].iter());}else{ans.push(n);}}ans.sort_unstable();ans}#[must_use]pub fn factorize_grouped(n:u64)->Vec<(u64,usize)>{if n<=1{return vec![];}let fac=factorize(n);let mut ans=vec![];let mut i=0;for(j,x)in fac.iter().enumerate(){if fac[i]!=*x{ans.push((fac[i],j-i));i=j;}}ans.push((fac[i],fac.len()-i));ans}pub fn divisors(n:u64)->Vec<u64>{if n==0{return vec![];}let mut ans=vec![1];for(p,exp)in factorize_grouped(n){let cnt=ans.len();ans.reserve(cnt*(exp+1));let mut mult=1;for _ in 0..exp{mult*=p;for i in 0..cnt{ans.push(ans[i]*mult);}}}ans.sort_unstable();ans}}
        pub mod primality {pub fn mod_mul(a:u64,b:u64,m:u64)->u64{use std::convert::TryInto;(u128::from(a)*u128::from(b)%u128::from(m)).try_into().unwrap()}pub fn mod_pow(mut a:u64,mut n:u64,m:u64)->u64{let mut ans=1;while n!=0{if n&1==1{ans=mod_mul(ans,a,m);}n>>=1;a=mod_mul(a,a,m);}ans}const BASES:[u64;7]=[2,325,9375,28178,450_775,9_780_504,1_795_265_022];#[must_use]pub fn is_prime(n:u64)->bool{if n<=2||n%2==0{return n==2;}let s=(n-1).trailing_zeros();let d=(n-1)>>s;for a in BASES{let a=a%n;if a<=1{continue;}let mut x=mod_pow(a,d,n);let mut y=0;for _ in 0..s{y=mod_mul(x,x,n);if y==1&&x!=1&&x!=n-1{return false;}x=y;}if y!=1{return false;}}true}}
        pub mod ascii {use std::{ops::{Deref,Index},str::FromStr,};static ASCII_CHARS:[char;128]={let mut arr=['\0';128];let mut i=0;while i<128{arr[i]=i as u8 as char;i+=1;}arr};pub struct Ascii(pub String);impl FromStr for Ascii{type Err=();fn from_str(s:&str)->Result<Self,Self::Err>{Ok(Ascii(s.to_owned()))}}impl Deref for Ascii{type Target=str;fn deref(&self)->&Self::Target{&self.0}}impl Index<usize>for Ascii{type Output=char;fn index(&self,index:usize)->&Self::Output{let byte=self.0.as_bytes()[index];&ASCII_CHARS[byte as usize]}}pub fn parse_char(c:char)->u8{c as u8-b'0'}}
    }

    pub(crate) mod macros {
        pub mod ps_snippets {}
        pub mod bitset {}
        pub mod disjoint_set {}
        pub mod fenwick {}
        pub mod lazy_segtree {}
        pub mod lazy_segtree_dyn {}
        pub mod polygon_simple {}
        pub mod bfs {}
        pub mod bicolor {}
        pub mod bottleneck_hungarian {}
        pub mod dijkstra {}
        pub mod edge_list {}
        pub mod hungarian {}
        pub mod scc {}
        pub mod toposort {}
        pub mod tree_compress {}
        pub mod hld {}
        pub mod io {}
        pub mod io_short {}
        pub mod enum_comb {}
        pub mod gcd {}
        pub mod kth_root {}
        pub mod modpow {}
        pub mod psuedo_rand {}
        pub mod sieve {}
        pub mod bigint {}
        pub mod binary_search {}
        pub mod bit_helper {}
        pub mod calendar {}
        pub mod dnc_opt {}
        pub mod gadgets {}
        pub mod lis {}
        pub mod two_sat {}
        pub mod fraction {}
        pub mod harmonic_lemma {}
        pub mod modfact {}
        pub mod modint {}
        pub mod ord_f64 {}
        pub mod factorization {}
        pub mod primality {}
        pub mod ascii {}
    }

    pub(crate) mod prelude {pub use crate::__cargo_equip::crates::*;}

    mod preludes {
        pub mod ps_snippets {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::{ascii,bfs,bicolor,bigint,binary_search,bit_helper,bitset,bottleneck_hungarian,calendar,dijkstra,disjoint_set,dnc_opt,edge_list,enum_comb,factorization,fenwick,fraction,gadgets,gcd,harmonic_lemma,hld,hungarian,io,io_short,kth_root,lazy_segtree,lazy_segtree_dyn,lis,modfact,modint,modpow,ord_f64,polygon_simple,primality,psuedo_rand,scc,sieve,toposort,tree_compress,two_sat};}
        pub mod bitset {}
        pub mod disjoint_set {}
        pub mod fenwick {}
        pub mod lazy_segtree {}
        pub mod lazy_segtree_dyn {}
        pub mod polygon_simple {}
        pub mod bfs {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::edge_list;}
        pub mod bicolor {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::edge_list;}
        pub mod bottleneck_hungarian {}
        pub mod dijkstra {}
        pub mod edge_list {}
        pub mod hungarian {}
        pub mod scc {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::edge_list;}
        pub mod toposort {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::edge_list;}
        pub mod tree_compress {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::{edge_list,hld};}
        pub mod hld {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::edge_list;}
        pub mod io {}
        pub mod io_short {}
        pub mod enum_comb {}
        pub mod gcd {}
        pub mod kth_root {}
        pub mod modpow {}
        pub mod psuedo_rand {}
        pub mod sieve {}
        pub mod bigint {}
        pub mod binary_search {}
        pub mod bit_helper {}
        pub mod calendar {}
        pub mod dnc_opt {}
        pub mod gadgets {}
        pub mod lis {}
        pub mod two_sat {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::{edge_list,scc};}
        pub mod fraction {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::gcd;}
        pub mod harmonic_lemma {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::modint;}
        pub mod modfact {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::modint;}
        pub mod modint {}
        pub mod ord_f64 {}
        pub mod factorization {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::{gcd,primality};}
        pub mod primality {}
        pub mod ascii {}
    }
}
